# Problem 29
# Find the number of distinct terms generated by a^b for 2 <= a <= 100 and 2 <= b <= 100

# NOTABLY, this could be done in a much easier fashion. I incorrectly assumed that 100^100 would hit an integer size limit. I did not bother to check either, so I designed this to work around possible integer size limits.


# Creates a list of all the prime factorization of the input number (with duplicates).
def prime_factorization(x):
    if x<=1 or x/1 != x//1:
        print("Error: attempted to find the prime factorization of an unsuitable number")
        return []
    else:
        prime_factorization_list = []
        i=1
        while x >= 2 and x % 2 == 0:
            prime_factorization_list.append(2)
            x /= 2
        while x >= 3 and x % 3 == 0:
            prime_factorization_list.append(3)
            x /= 3
        i = 6
        while i - 1 <= x:
            p = i-1
            while x % p == 0:
                prime_factorization_list.append(p)
                x/=p
            p += 2
            while x % p == 0:
                prime_factorization_list.append(p)
                x/=p
            i += 6

    return prime_factorization_list

# Creates a prime factorization of the input number as a list of tuple pairs, where the first number in a pair is the prime factor, while the second number is the number of times that it occurs.
def prime_factorization_tuple(x):
    if x<=1 or x/1 != x//1:
        print("Error: attempted to find the prime factorization of an unsuitable number")
        return []
    else:
        prime_factorization_tuple_list = []
        prime_factors = []
        factor_count = []
        i=1
        while x >= 2 and x % 2 == 0:
            if 2 in prime_factors:
                factor_count[-1] += 1
            else:
                prime_factors.append(2)
                factor_count.append(1)
            x /= 2
        while x >= 3 and x % 3 == 0:
            if 3 in prime_factors:
                factor_count[-1] += 1
            else:
                prime_factors.append(3)
                factor_count.append(1)
            x /= 3
        i = 6
        while i - 1 <= x:
            p = i-1
            while x % p == 0:
                if p in prime_factors:
                    factor_count[-1] += 1
                else:
                    prime_factors.append(p)
                    factor_count.append(1)
                x/=p
            p += 2
            while x % p == 0:
                if p in prime_factors:
                    factor_count[-1] += 1
                else:
                    prime_factors.append(p)
                    factor_count.append(1)
                x/=p
            i += 6
        j = 0
        while j<len(prime_factors):
            prime_factorization_tuple_list.append((prime_factors[j],factor_count[j]))
            j += 1

    return prime_factorization_tuple_list


# Finds the number of distinct terms generated by a^b, where a and b have the same range from 2 to "cap". 
# Requires prime_factorization as a helper function.
def distinct_term_total(cap):
    distinct = 0
    i = 2
    power_factorization_list = []
    while i <= cap:
        j = 2
        base_factorization = prime_factorization_tuple(i)
        while j <= cap:
            k = 2
            while k <= j:
                temp_factorization = []
                m = 0
                while m < len(base_factorization):
                    temp_factorization.append((base_factorization[m][0],k*base_factorization[m][1]))
                    m += 1
                k += 1
            if temp_factorization not in power_factorization_list:
                power_factorization_list.append(temp_factorization)
                distinct += 1
            j += 1
        i += 1 

    return distinct


print(distinct_term_total(100))